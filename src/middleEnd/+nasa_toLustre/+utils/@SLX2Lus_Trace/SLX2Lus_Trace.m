%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Author: Hamza Bourbouh <hamza.bourbouh@nasa.gov>
% Notices:
%
% Copyright @ 2020 United States Government as represented by the 
% Administrator of the National Aeronautics and Space Administration.  All 
% Rights Reserved.
%
% Disclaimers
%
% No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY 
% WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING,
% BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM 
% TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS 
% FOR A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
% THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT 
% DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS 
% AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY 
% GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING 
% DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING 
% FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS 
% ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF PRESENT 
% IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS."
%
% Waiver and Indemnity:  RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS 
% AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, 
% AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT 
% SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR 
% LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS BASED 
% ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT 
% SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS 
% CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE 
% EXTENT PERMITTED BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER 
% SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
% 
% Notice: The accuracy and quality of the results of running CoCoSim 
% directly corresponds to the quality and accuracy of the model and the 
% requirements given as inputs to CoCoSim. If the models and requirements 
% are incorrectly captured or incorrectly input into CoCoSim, the results 
% cannot be relied upon to generate or error check software being developed. 
% Simply stated, the results of CoCoSim are only as good as
% the inputs given to CoCoSim.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef SLX2Lus_Trace < handle
    % This traceability is generating two type of files. One is XML
    % contains more detailed information. One is Json generated to be
    % equivalent to the one generated by IOWA Lustre compiler
    properties
        json_struct;
        traceDOM;
        model_full_path;
        xml_file_path;
        json_file_path;
        traceRootNode;
        nodes_map;
        contracts_map;
        current_node;
        current_inputs;
        current_outputs;
        current_variables;
    end
    
    methods
        
        function obj = SLX2Lus_Trace(model_full_path, ...
                xml_trace_file_name, json_trace_file_name)
            obj.traceDOM = com.mathworks.xml.XMLUtils.createDocument('SLX2LusTrace');
            obj.model_full_path = model_full_path;
            obj.xml_file_path = xml_trace_file_name;
            obj.json_file_path = json_trace_file_name;
            obj.init();
        end
        
        function init(obj)
            % Maps
            obj.nodes_map = containers.Map();
            obj.contracts_map = containers.Map();
            %XML
            obj.json_struct = {};
            obj.traceRootNode = obj.traceDOM.getDocumentElement;
            obj.traceRootNode.setAttribute('ModelPath', obj.model_full_path);
            comment = obj.traceDOM.createComment(...
                sprintf('This file has been generated by the CoCoSim tool :%s',...
                datestr(now)));
            obj.traceRootNode.appendChild(comment);
            
            %JSON
            %             s = struct();
            %             s.ModelPath = obj.model_full_path;
            %             s.MetaInfo = 'This file has been generated by the CoCoSim tool';
            %             s.DateTime = datestr(now);
            %             obj.addStructMapping(s);
        end
        
        function fname = getJsonMappingFileName(obj)
            fname = obj.json_file_path;
        end
        function traceRootNode = getTraceRootNode(obj)
            traceRootNode = obj.traceRootNode;
        end
        function write(obj)
            %XML
            xmlwrite(obj.xml_file_path, obj.traceDOM);
            %JSON
            fid= fopen(obj.json_file_path, 'w+');
            if fid~=-1
                json_model = coco_nasa_utils.MatlabUtils.jsonencode(obj.json_struct); 
                json_model = strrep(json_model,'\/','/');
                fprintf(fid, '%s\n', json_model);
            end
            fclose(fid);
        end
        
        function addStructMapping(obj, s)
            obj.json_struct{end+1} = s;
        end
        % Nodes management
        function element = create_Node_Element(obj, OriginPath, ...
                node_name, isContract)
            if nargin < 4
                isContract = 0;
            end
            %XML
            element = obj.traceDOM.createElement('Node');
            element.setAttribute('NodeName', node_name);
            element.setAttribute('OriginPath', OriginPath);
            element.setAttribute('IsContract', num2str(isContract));
            obj.traceRootNode.appendChild(element);
            obj.current_node = element;
            %JSON
            s = struct();
            s.OriginPath = OriginPath;
            if isContract
                s.ContractName = node_name;
            else
                s.NodeName = node_name;
            end
            obj.addStructMapping(s);
            
            % Maps
            if isContract
                obj.contracts_map(node_name) = element;
            else
                obj.nodes_map(node_name) = element;
            end
        end
        %%
        function node = create_abstractNode_Element(obj, OriginPath, ...
                node_name, inputs_trace_cell, outputs_trace_cell)
            isContract = 0;
            %% node
            % xml
            node = obj.traceDOM.createElement('Node');
            node.setAttribute('NodeName', node_name);
            node.setAttribute('OriginPath', OriginPath);
            node.setAttribute('IsContract', num2str(isContract));
            obj.traceRootNode.appendChild(node);
            %JSON
            s = struct();
            s.OriginPath = OriginPath;
            s.NodeName = node_name;
            obj.addStructMapping(s);
                        
            %% inputs
            node_inputs = obj.traceDOM.createElement('InputList');
            node.appendChild(node_inputs);
            for i=1:length(inputs_trace_cell)
                e = obj.create_Data_Trace_Element('Inport', ...
                    inputs_trace_cell{i}.VariableName, ...
                    inputs_trace_cell{i}.OriginPath, ...
                    inputs_trace_cell{i}.PortNumber,...
                    inputs_trace_cell{i}.Width, ...
                    inputs_trace_cell{i}.Index, 0, ...
                    inputs_trace_cell{i}.IsNotInSimulink, ...
                    inputs_trace_cell{i}.PortType);
                node_inputs.appendChild(e);
                %JSON
                s = inputs_trace_cell{i};
                s.NodeName = node_name;
                s.VariableType = 'Inport';
                s.PortNumber = num2str(s.PortNumber);
                s.Width = num2str(s.Width);
                s.Index = num2str(s.Index);
                obj.addStructMapping(s);
            end
            %% inputs
            node_outputs = obj.traceDOM.createElement('InputList');
            node.appendChild(node_outputs);
            for i=1:length(outputs_trace_cell)
                e = obj.create_Data_Trace_Element('Outport', ...
                    outputs_trace_cell{i}.VariableName, ...
                    outputs_trace_cell{i}.OriginPath, ...
                    outputs_trace_cell{i}.PortNumber,...
                    outputs_trace_cell{i}.Width, ...
                    outputs_trace_cell{i}.Index, 0, ...
                    outputs_trace_cell{i}.IsNotInSimulink, ...
                    outputs_trace_cell{i}.PortType);
                node_outputs.appendChild(e);
                %JSON
                s = outputs_trace_cell{i};
                s.NodeName = node_name;
                s.VariableType = 'Outport';
                s.PortNumber = num2str(s.PortNumber);
                s.Width = num2str(s.Width);
                s.Index = num2str(s.Index);
                obj.addStructMapping(s);
            end
            % Maps
            obj.nodes_map(node_name) = node;
        end
        
        %% Inputs management
        function element = create_Inputs_Element(obj)
            element = obj.traceDOM.createElement('InputList');
            obj.current_node.appendChild(element);
            obj.current_inputs = element;
        end
        
        % Outputs management
        function element = create_Outputs_Element(obj)
            element = obj.traceDOM.createElement('OutputList');
            obj.current_node.appendChild(element);
            obj.current_outputs = element;
        end
        
        % Variables management
        function element = create_Variables_Element(obj)
            element = obj.traceDOM.createElement('VarList');
            obj.current_node.appendChild(element);
            obj.current_variables = element;
        end
        
        
        function element = add_Input(obj, var_name, originPath, port, width,...
                index, isInsideContract, IsNotInSimulink, portType)
            element = obj.add_InputOutputVar('Inport', var_name, ...
                originPath, port, width, index, isInsideContract,...
                IsNotInSimulink, portType);
        end
        function element = add_Output(obj, var_name, originPath, port, width,...
                index, isInsideContract, IsNotInSimulink, portType)
            element = obj.add_InputOutputVar('Outport', var_name, ...
                originPath, port, width, index, isInsideContract,...
                IsNotInSimulink, portType);
        end
        function element = add_Var(obj, var_name, originPath, port, width,...
                index, isInsideContract, IsNotInSimulink, portType)
            element = obj.add_InputOutputVar('Variable', var_name, ...
                originPath, port, width, index, isInsideContract,...
                IsNotInSimulink, portType);
        end
        function element = add_InputOutputVar(obj, type, var_name, originPath,...
                port, width, index, isInsideContract, IsNotInSimulink, portType)
            if ~exist('IsNotInSimulink', 'var')
                IsNotInSimulink = 0;
            end
            if ~exist('isInsideContract', 'var')
                isInsideContract = 0;
            end
            if ~exist('portType', 'var')
                % for BusCreator values are computed from Inports
                portType = 'Outports';
            end
            element = obj.create_Data_Trace_Element(type, var_name, ...
                originPath, port, width, index, isInsideContract, ...
                IsNotInSimulink, portType);
            if strcmp(type, 'Inport')
                obj.current_inputs.appendChild(element);
            elseif strcmp(type, 'Outport')
                obj.current_outputs.appendChild(element);
            else
                obj.current_variables.appendChild(element);
            end
        end
        
        
        
        % Generic functions
        function element = create_Data_Trace_Element(obj,...
                varType, var_name, originPath, port, width, index, ...
                isInsideContract, isNotInSimulink, portType)
            element = obj.traceDOM.createElement(varType);
            element.setAttribute('VariableName', var_name);
            element.setAttribute('IsNotInSimulink', num2str(isNotInSimulink));
            element.setAttribute('IsInsideContract', num2str(isInsideContract));
            element.appendChild(obj.create_Text_Node('OriginPath', originPath));
            element.appendChild(obj.create_Text_Node('PortNumber', num2str(port)));
            element.appendChild(obj.create_Text_Node('PortType', portType));
            element.appendChild(obj.create_Text_Node('Width', num2str(width)));
            element.appendChild(obj.create_Text_Node('Index', num2str(index)));
            
            %JSON
            s = struct();
            s.OriginPath = originPath;
            if isInsideContract
                s.ContractName = char(obj.current_node.getAttribute('NodeName'));
            else
                s.NodeName = char(obj.current_node.getAttribute('NodeName'));
            end
            s.VariableName = var_name;
            s.VariableType = varType;
            s.PortNumber = num2str(port);
            s.PortType = portType;
            s.Width = num2str(width);
            s.Index = num2str(index);
            obj.addStructMapping(s);
        end
        
        function element = create_Text_Node(obj, textLabel, text_content)
            element = obj.traceDOM.createElement(textLabel);
            element.appendChild(obj.traceDOM.createTextNode(text_content));
        end
        
        
        % add property for IOWA traceability used in cocoSpecKind2.m
        function  add_Property(obj,...
                origin_path, ContractName, PropertyName, PropertyIndex, propertyType)
            element = obj.traceDOM.createElement('Property');
            element.setAttribute('PropertyType', propertyType);
            element.setAttribute('OriginPath', origin_path);
            element.setAttribute('ParentName', ContractName);
            element.setAttribute('PropertyName', PropertyName);
            %element.appendChild(obj.create_Text_Node('Index', num2str(PropertyIndex)));
            obj.traceRootNode.appendChild(element);
            %JSON
            s = struct();
            s.OriginPath = origin_path;
            s.ContractName = ContractName;
            s.PropertyName = PropertyName;
            s.PropertyType = propertyType;
            s.Index = PropertyIndex;
            obj.addStructMapping(s);
        end
        
        % functions for compatibility with old traceability used in
        % lustre_compiler
    end
    
    methods(Static)
        xRoot = getxRoot(xml_trace_var)
        node_name = get_lustre_node_from_Simulink_block_name(trace_root,Simulink_block_name)
        simulink_block_name = get_Simulink_block_from_lustre_node_name(trace_root, lustre_node_name, Sim_file_name, new_model_name)
        variables_names = get_tracable_variables(xml_trace, node_name)
        [originPath, port, width, index, isInsideContract, IsNotInSimulink, portType] = ...
            get_SlxBlockName_from_LusVar_UsingXML(xml_trace, node_name, var_name)
    end
end
