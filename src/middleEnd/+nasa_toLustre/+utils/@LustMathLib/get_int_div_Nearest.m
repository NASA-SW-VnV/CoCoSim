function [node, external_nodes_i, opens, abstractedNodes] = get_int_div_Nearest(varargin)
    import nasa_toLustre.lustreAst.*
    opens = {};
    abstractedNodes = {};
    external_nodes_i = {'LustMathLib_int_div_Ceiling'};
    conds = {};
    thens = {};
    %y = 0
    conds{1} = BinaryExpr(BinaryExpr.EQ, VarIdExpr('y'), IntExpr(0));
    %if x>0 then 2147483647 else -2147483648
    thens{1} = IteExpr(...
        BinaryExpr(BinaryExpr.GT, VarIdExpr('x'), IntExpr(0)),...
        IntExpr(2147483647), IntExpr(-2147483648),...
        true);
    % x mod y = 0
    conds{end + 1} = BinaryExpr(...
        BinaryExpr.EQ, ...
        BinaryExpr(BinaryExpr.MOD, VarIdExpr('x'), VarIdExpr('y')), ...
        IntExpr(0));
    % x/y
    thens{end + 1} = BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y'));
    %(((x mod y) * 2) = y)
    conds{end + 1} = BinaryExpr(BinaryExpr.EQ, ...
        BinaryExpr(BinaryExpr.MULTIPLY, ...
        BinaryExpr(BinaryExpr.MOD, ...
        VarIdExpr('x'), ...
        VarIdExpr('y')),...
        IntExpr(2)),...
        VarIdExpr('y'));
    %int_div_Ceiling(x,y)
    thens{end + 1} = NodeCallExpr('int_div_Ceiling',...
        {VarIdExpr('x'), VarIdExpr('y')});
    %(y > 0) and ((x mod y)*2 >= y )
    conds{end + 1} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.GT, ...
        VarIdExpr('y'),...
        IntExpr(0)), ...
        BinaryExpr(BinaryExpr.GT, ...
        BinaryExpr(BinaryExpr.MULTIPLY, ...
        BinaryExpr(BinaryExpr.MOD, ...
        VarIdExpr('x'), ...
        VarIdExpr('y')),...
        IntExpr(2)),...
        VarIdExpr('y'))...
        );
    % x/y + 1
    thens{end + 1} = BinaryExpr(...
        BinaryExpr.PLUS, ...
        BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y')), ...
        IntExpr(1));
    %(y < 0) and ((x mod y)*2 >= (-y))
    conds{end + 1} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.LT, ...
        VarIdExpr('y'),...
        IntExpr(0)), ...
        BinaryExpr(BinaryExpr.GT, ...
        BinaryExpr(BinaryExpr.MULTIPLY, ...
        BinaryExpr(BinaryExpr.MOD, ...
        VarIdExpr('x'), ...
        VarIdExpr('y')),...
        IntExpr(2)),...
        UnaryExpr(UnaryExpr.NEG,VarIdExpr('y')))...
        );
    % x/y - 1
    thens{end + 1} = BinaryExpr(...
        BinaryExpr.MINUS, ...
        BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y')), ...
        IntExpr(1));
    %x/y
    thens{end + 1} = BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y'));
    bodyElts{1} = LustreEq(...
        VarIdExpr('z'), ...
        IteExpr.nestedIteExpr(conds, thens)...
        );
    node = LustreNode();
    node.setMetaInfo('Rounds number to the nearest representable value. If a tie occurs, rounds toward positive infinity');
    node.setName('int_div_Nearest');
    node.setInputs({LustreVar('x', 'int'), LustreVar('y', 'int')});
    node.setOutputs(LustreVar('z', 'int'));
    node.setBodyEqs(bodyElts);
    node.setIsMain(false);
end