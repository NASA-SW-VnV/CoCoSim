%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% Author: Hamza Bourbouh <hamza.bourbouh@nasa.gov>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
function [node, external_nodes_i, opens, abstractedNodes] = get_int_div_Ceiling(varargin)
    import nasa_toLustre.lustreAst.*
    opens = {};
    abstractedNodes = {};
    external_nodes_i = {strcat('LustMathLib_', 'abs_int')};
    
    %y = 0
    conds{1} = BinaryExpr(BinaryExpr.EQ, VarIdExpr('y'), IntExpr(0));
    %if x>0 then 2147483647 else -2147483648
    thens{1} = IteExpr(...
        BinaryExpr(BinaryExpr.GT, VarIdExpr('x'), IntExpr(0)),...
        IntExpr(2147483647), IntExpr(-2147483648),...
        true);
    % x mod y = 0
    conds{2} = BinaryExpr(...
        BinaryExpr.EQ, ...
        BinaryExpr(BinaryExpr.MOD, VarIdExpr('x'), VarIdExpr('y')), ...
        IntExpr(0));
    % x/y
    thens{2} = BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y'));
    %(abs_int(y) > abs_int(x) and x*y>0)
    conds{3} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.GT, ...
        NodeCallExpr('abs_int', VarIdExpr('y')),...
        NodeCallExpr('abs_int', VarIdExpr('x'))), ...
        BinaryExpr(BinaryExpr.GT, ...
        BinaryExpr(BinaryExpr.MULTIPLY, VarIdExpr('x'), VarIdExpr('y')),...
        IntExpr(0))...
        );
    % 1
    thens{3} = IntExpr(1);
    %(abs_int(y) > abs_int(x) and x*y<0)
    conds{4} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.GT, ...
        NodeCallExpr('abs_int', VarIdExpr('y')),...
        NodeCallExpr('abs_int', VarIdExpr('x'))), ...
        BinaryExpr(BinaryExpr.LT, ...
        BinaryExpr(BinaryExpr.MULTIPLY, VarIdExpr('x'), VarIdExpr('y')),...
        IntExpr(0))...
        );
    % 0
    thens{4} = IntExpr(0);
    % (x>0 and y < 0)
    conds{5} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.GT, ...
        VarIdExpr('x'),...
        IntExpr(0)), ...
        BinaryExpr(BinaryExpr.LT, ...
        VarIdExpr('y'),...
        IntExpr(0))...
        );
    %x/y
    thens{5} = BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y'));
    % (x<0 and y > 0)
    conds{6} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.LT, ...
        VarIdExpr('x'),...
        IntExpr(0)), ...
        BinaryExpr(BinaryExpr.GT, ...
        VarIdExpr('y'),...
        IntExpr(0))...
        );
    %(-x)/(-y)
    thens{6} = BinaryExpr(...
        BinaryExpr.DIVIDE, ...
        UnaryExpr(UnaryExpr.NEG, VarIdExpr('x')), ...
        UnaryExpr(UnaryExpr.NEG, VarIdExpr('y')));
    
    % (x < 0 and y < 0)
    conds{7} = BinaryExpr(...
        BinaryExpr.AND, ...
        BinaryExpr(BinaryExpr.LT, ...
        VarIdExpr('x'),...
        IntExpr(0)), ...
        BinaryExpr(BinaryExpr.LT, ...
        VarIdExpr('y'),...
        IntExpr(0))...
        );
    %(-x)/(-y) + 1
    thens{7} = BinaryExpr(BinaryExpr.PLUS,...
        BinaryExpr(...
        BinaryExpr.DIVIDE, ...
        UnaryExpr(UnaryExpr.NEG, VarIdExpr('x')), ...
        UnaryExpr(UnaryExpr.NEG, VarIdExpr('y'))),...
        IntExpr(1));
    %x/y + 1
    thens{8} = BinaryExpr(BinaryExpr.PLUS,...
        BinaryExpr(BinaryExpr.DIVIDE, VarIdExpr('x'), VarIdExpr('y')),...
        IntExpr(1));
    bodyElts{1} = LustreEq(...
        VarIdExpr('z'), ...
        IteExpr.nestedIteExpr(conds, thens)...
        );
    node = LustreNode();
    node.setMetaInfo('Rounds positive and negative numbers toward positive infinity');
    node.setName('int_div_Ceiling');
    node.setInputs({LustreVar('x', 'int'), LustreVar('y', 'int')});
    node.setOutputs(LustreVar('z', 'int'));
    node.setBodyEqs(bodyElts);
    node.setIsMain(false);
end
