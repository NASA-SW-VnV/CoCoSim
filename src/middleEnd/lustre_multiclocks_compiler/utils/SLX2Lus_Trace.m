%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2017 United States Government as represented by the
% Administrator of the National Aeronautics and Space Administration.
% All Rights Reserved.
% Author: Hamza Bourbouh <hamza.bourbouh@nasa.gov>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef SLX2Lus_Trace < handle
    % This traceability is generating two type of files. One is XML
    % contains more detailed information. One is Json generated to be
    % equivalent to the one generated by IOWA Lustre compiler
    properties
        json_struct;
        traceDOM;
        model_full_path;
        xml_file_path;
        json_file_path;
        traceRootNode;
        current_node;
        current_inputs;
        current_outputs;
        current_variables;
    end
    
    methods
        
        function obj = SLX2Lus_Trace(model_full_path, ...
                xml_trace_file_name, json_trace_file_name)
            obj.traceDOM = com.mathworks.xml.XMLUtils.createDocument('SLX2LusTrace');
            obj.model_full_path = model_full_path;
            obj.xml_file_path = xml_trace_file_name;
            obj.json_file_path = json_trace_file_name;
            obj.init();
        end
        
        function init(obj)
            %XML
            obj.json_struct = {};
            obj.traceRootNode = obj.traceDOM.getDocumentElement;
            obj.traceRootNode.setAttribute('ModelPath', obj.model_full_path);
            comment = obj.traceDOM.createComment(...
                sprintf('This file has been generated by the CoCoSim tool :%s',...
                datestr(now)));
            obj.traceRootNode.appendChild(comment);
            
            %JSON
            %             s = struct();
            %             s.ModelPath = obj.model_full_path;
            %             s.MetaInfo = 'This file has been generated by the CoCoSim tool';
            %             s.DateTime = datestr(now);
            %             obj.addStructMapping(s);
        end
        
        function fname = getJsonMappingFileName(obj)
            fname = obj.json_file_path;
        end
        function traceRootNode = getTraceRootNode(obj)
            traceRootNode = obj.traceRootNode;
        end
        function write(obj)
            %XML
            xmlwrite(obj.xml_file_path, obj.traceDOM);
            %JSON
            fid= fopen(obj.json_file_path, 'w+');
            if fid~=-1
                json_model = json_encode(obj.json_struct); %faire en sorte qu'il y ait des sauts de ligne dans la réécriture de la fonction json_encode
                json_model = strrep(json_model,'\/','/');
                fprintf(fid, '%s\n', json_model);
            end
            fclose(fid);
        end
        
        function addStructMapping(obj, s)
            obj.json_struct{end+1} = s;
        end
        % Nodes management
        function element = create_Node_Element(obj, block_origin_name, ...
                node_name, isContract)
            if nargin < 4
                isContract = 0;
            end
            %XML
            element = obj.traceDOM.createElement('Node');
            element.setAttribute('NodeName', node_name);
            element.setAttribute('OriginPath', block_origin_name);
            element.setAttribute('IsContract', num2str(isContract));
            obj.traceRootNode.appendChild(element);
            obj.current_node = element;
            %JSON
            s = struct();
            s.OriginPath = block_origin_name;
            if isContract
                s.ContractName = node_name;
            else
                s.NodeName = node_name;
            end
            obj.addStructMapping(s);
        end
        
        % Inputs management
        function element = create_Inputs_Element(obj)
            element = obj.traceDOM.createElement('InputList');
            obj.current_node.appendChild(element);
            obj.current_inputs = element;
        end
        
        % Outputs management
        function element = create_Outputs_Element(obj)
            element = obj.traceDOM.createElement('OutputList');
            obj.current_node.appendChild(element);
            obj.current_outputs = element;
        end
        
        % Variables management
        function element = create_Variables_Element(obj)
            element = obj.traceDOM.createElement('VarList');
            obj.current_node.appendChild(element);
            obj.current_variables = element;
        end
        
        
        function element = add_InputOutputVar(obj, type, var_name, originPath, port, width, index, isInsideContract, IsNotInSimulink)
            if ~exist('IsNotInSimulink', 'var')
                IsNotInSimulink = 0;
            end
            if ~exist('isInsideContract', 'var')
                isInsideContract = 0;
            end
            element = obj.create_Data_Trace_Element(type, var_name, originPath, port, width, index, isInsideContract, IsNotInSimulink);
            if isequal(type, 'Inport')
                obj.current_inputs.appendChild(element);
            elseif isequal(type, 'Outport')
                obj.current_outputs.appendChild(element);
            else
                obj.current_variables.appendChild(element);
            end
        end
        
        
        
        % Generic functions
        function element = create_Data_Trace_Element(obj,...
                varType, var_name, originPath, port, width, index, isInsideContract, isNotInSimulink)
            element = obj.traceDOM.createElement(varType);
            element.setAttribute('VariableName', var_name);
            element.appendChild(obj.create_Text_Node('OriginPath', originPath));
            element.appendChild(obj.create_Text_Node('PortNumber', num2str(port)));
            element.appendChild(obj.create_Text_Node('Width', num2str(width)));
            element.appendChild(obj.create_Text_Node('Index', num2str(index)));
            element.setAttribute('IsNotInSimulink', num2str(isNotInSimulink));
            
            %JSON
            s = struct();
            s.OriginPath = originPath;
            if isInsideContract
                s.ContractName = char(obj.current_node.getAttribute('NodeName'));
            else
                s.NodeName = char(obj.current_node.getAttribute('NodeName'));
            end
            s.VariableName = var_name;
            s.VariableType = varType;
            s.Width = num2str(width);
            s.Index = num2str(index);
            obj.addStructMapping(s);
        end
        
        function element = create_Text_Node(obj, textLabel, text_content)
            element = obj.traceDOM.createElement(textLabel);
            element.appendChild(obj.traceDOM.createTextNode(text_content));
        end
        
        
        % add property for IOWA traceability used in cocoSpecKind2.m
        function  add_Property(obj,...
                origin_path, ContractName, PropertyName, PropertyIndex, propertyType)
            element = obj.traceDOM.createElement('Property');
            element.setAttribute('PropertyType', propertyType);
            element.setAttribute('OriginPath', origin_path);
            element.setAttribute('ParentName', ContractName);
            element.setAttribute('PropertyName', PropertyName);
            %element.appendChild(obj.create_Text_Node('Index', num2str(PropertyIndex)));
            obj.traceRootNode.appendChild(element);
            %JSON
            s = struct();
            s.OriginPath = origin_path;
            s.ContractName = ContractName;
            s.PropertyName = PropertyName;
            s.PropertyType = propertyType;
            s.Index = PropertyIndex;
            obj.addStructMapping(s);
        end
        
        % functions for compatibility with old traceability used in
        % lustre_compiler
        function element = add_Input(obj, var_name, originPath, port, width)
            % this function is only used in write_chart.
            %Use add_InputOutputVar for ToLustre function
            element = obj.add_InputOutputVar('Inport', var_name, originPath, port, width, 1, 0, 0);
        end
        function element = add_Output(obj, var_name, originPath, port, width)
            % this function is only used in write_chart.
            %Use add_InputOutputVar for ToLustre function
            element = obj.add_InputOutputVar('Outport', var_name, originPath, port, width, 1, 0, 0);
        end
    end
    
    methods(Static)
        function node_name = get_lustre_node_from_Simulink_block_name(trace_root,Simulink_block_name)
            if isa(trace_root, 'char')
                DOMNODE = xmlread(trace_root);
                xRoot = DOMNODE.getDocumentElement;
            elseif isa(trace_root, 'SLX2Lus_Trace')
                xRoot = trace_root.traceRootNode;
            else
                xRoot = trace_root;
            end
            xml_nodes = xRoot.getElementsByTagName('Node');
            node_name = '';
            for idx_node=0:xml_nodes.getLength-1
                block_name = xml_nodes.item(idx_node).getAttribute('OriginPath');
                if strcmp(block_name, Simulink_block_name)
                    node_name = char(xml_nodes.item(idx_node).getAttribute('NodeName'));
                    break;
                end
                
            end
        end
        
        function simulink_block_name = get_Simulink_block_from_lustre_node_name(...
                trace_root, lustre_node_name, Sim_file_name, new_model_name)
            if ischar(trace_root)
                DOMNODE = xmlread(trace_root);
                xRoot = DOMNODE.getDocumentElement;
            elseif isa(trace_root, 'SLX2Lus_Trace')
                xRoot = trace_root.traceRootNode;
            else
                xRoot = trace_root;
            end
            simulink_block_name = '';
            xml_nodes = xRoot.getElementsByTagName('Node');
            for idx_node=0:xml_nodes.getLength-1
                lustre_name = xml_nodes.item(idx_node).getAttribute('NodeName');
                if strcmp(lustre_name,lustre_node_name)
                    simulink_block_name = char(xml_nodes.item(idx_node).getAttribute('OriginPath'));
                    if nargin == 4
                        simulink_block_name = regexprep(simulink_block_name,strcat('^',Sim_file_name,'/(\w)'),strcat(new_model_name,'/$1'));
                    end
                    break;
                end
                
            end
        end
        % get variables +inputs + outputs names of a node
        function variables_names = get_tracable_variables(xRoot, node_name)
            
            variables_names = {};
            nodes = xRoot.getElementsByTagName('Node');
            for idx_node=0:nodes.getLength-1
                block_name_node = nodes.item(idx_node).getAttribute('NodeName');
                if strcmp(block_name_node, node_name)
                    inputs = nodes.item(idx_node).getElementsByTagName('OutputList');
                    for idx_input=0:inputs.getLength-1
                        input = inputs.item(idx_input);
                        variables_names{end + 1} = ...
                            char(input.getAttribute('VariableName='));
                    end
                    outputs = nodes.item(idx_node).getElementsByTagName('Output');
                    for idx_output=0:outputs.getLength-1
                        output = outputs.item(idx_output);
                        variables_names{end + 1} = ...
                            char(output.getAttribute('VariableName='));
                    end
                    variables = nodes.item(idx_node).getElementsByTagName('VarList');
                    for idx_var=0:variables.getLength-1
                        var = variables.item(idx_var);
                        variables_names{end + 1} = ...
                            char(var.getAttribute('VariableName='));
                    end
                end
            end
        end
    end
end
