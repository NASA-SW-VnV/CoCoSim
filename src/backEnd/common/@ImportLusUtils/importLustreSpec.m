function [new_model_path, status] = importLustreSpec(...
        model_path,...
        lus_json_path,...
        cocosim_trace_file, ...
        createNewFile)
    %new_model_path = importLustreSpec(model_path, contract_path)
    % Inputs:
    % model_path : the path of Simulink model
    % lus_json_path : the Json that contains the lustre represenation
    % generated by Lustrec.
    % Outputs:
    % new_model_path: the path of the new Simulink model that has the 
    % Spec of the associated model.
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Copyright (c) 2017 United States Government as represented by the
    % Administrator of the National Aeronautics and Space Administration.
    % All Rights Reserved.
    % Author: Hamza Bourbouh <hamza.bourbouh@nasa.gov>
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    
    narginchk(3,4);
    status = 0;
    [coco_dir, ~, ~] = fileparts(lus_json_path);
    [model_dir, base_name, ~] = fileparts(model_path);

    no_traceability = false;
    if nargin < 3 || isempty(cocosim_trace_file)
        cocosim_trace_file = '';
        no_traceability = true;
    end
    if nargin < 4
        createNewFile = 0;
    end
    try
        if bdIsLoaded(base_name)
            save_system(model_path)
        end
        bdclose('all')
        new_model_path = '';
        data = BUtils.read_json(lus_json_path);



        if createNewFile
            % we add a Postfix to differentiate it with the original Simulink model
            new_model_name = strcat(base_name,'_with_contracts');
            new_name = fullfile(model_dir,strcat(new_model_name,'.slx'));

            display_msg(['Cocospec path: ' new_name ], MsgType.INFO, 'generate_invariants_Zustre', '');

            if exist(new_name,'file')
                if bdIsLoaded(new_model_name)
                    close_system(new_model_name,0)
                end
                delete(new_name);
            end

            %we load the original model
            load_system(model_path);
            try close_system(new_name,0), catch, end
            %we save it as the output model
            save_system(model_path,new_name, 'OverwriteIfChangedOnDisk', true);
        else
            new_model_name = base_name;
            new_name = model_path;
        end

        %get tracability
        if ~no_traceability
            DOMNODE = xmlread(cocosim_trace_file);
            xRoot = DOMNODE.getDocumentElement;
        end
        nb_coco = 0;


        [status, translated_nodes_path, ~]  = lus2slx(lus_json_path, coco_dir, [], [], 1);
        if status
            return;
        end
        [~, translated_nodes, ~] = fileparts(translated_nodes_path);
        load_system(translated_nodes_path);
        load_system(new_name);
        nodes = data.nodes;
        for node = fieldnames(nodes)'
            node_name = node{1};
            node_struct = nodes.(node_name);
            original_name = node_struct.original_name;
            if ~(isfield(node_struct, 'contract') ...
                    && strcmp(node_struct.contract, 'true'))
                %Support only contracts
                continue;
            end
            if no_traceability 
                % Give the current opened Subsystem
                simulink_block_name = gcs;
            else
                simulink_block_name = SLX2Lus_Trace.get_Simulink_block_from_lustre_node_name(xRoot, ...
                    original_name, base_name, new_model_name);
            end
            if strcmp(simulink_block_name, '')
                continue;
            end
            isBdRoot = strcmp(get_param(simulink_block_name, 'Type'), 'block_diagram');
            if isBdRoot
                simulink_block_name = strcat(new_model_name,'/',base_name);
            end
            parent_block_name = fileparts(simulink_block_name);
            %for having a good order of blocks
            
            if isBdRoot
                position  = BUtils.get_obs_position(new_model_name);
            else
                position  = get_param(simulink_block_name,'Position');
            end
            x = position(1);
            y = position(2)+250;

            %Adding the cocospec subsystem related with the Simulink subsystem
            %"simulink_block_name"
            cocospec_block_path = strcat(simulink_block_name,'_', original_name);
            n = 1;
            while getSimulinkBlockHandle(cocospec_block_path) ~= -1
                cocospec_block_path = strcat(cocospec_block_path, num2str(n));
                n = n + 1;
                y = y+250;
            end
            node_subsystem = strcat(translated_nodes, '/', BUtils.adapt_block_name(node_name));
            add_block(node_subsystem,...
                cocospec_block_path,...
                'Position',[(x+100) y (x+250) (y+50)]);
            ImportLusUtils.set_mask_parameters(cocospec_block_path);
            nb_coco = nb_coco + 1;

            %we plot the invariant of the block
%             scope_block_path = strcat(simulink_block_name,'_scope',num2str(n));
%             scopeHandle = add_block('simulink/Commonly Used Blocks/Scope',...
%                 scope_block_path,...
%                 'MakeNameUnique', 'on', ...
%                 'Position',[(x+300) y (x+350) (y+50)]);
% 
%             %we link the Scope with cocospec block
%             SrcBlkH = get_param(cocospec_block_path, 'PortHandles');
%             DstBlkH = get_param(scopeHandle, 'PortHandles');
%             add_line(parent_block_name, SrcBlkH.Outport(1), DstBlkH.Inport(1), 'autorouting', 'on');
%             if no_traceability 
%                 % Do Not Link contract, keep it for the user to do it.
%             else
%                 blk_inputs = node_struct.inputs;
%                 %link inputs to the subsystem.
%                 for index=1:numel(blk_inputs)
%                     var_name = BUtils.adapt_block_name(blk_inputs(index).original_name);
%                     input_block_name = ImportLusUtils.get_input_block_name_from_variable(xRoot, original_name, var_name, base_name,new_model_name);
%                     ImportLusUtils.link_block_with_its_cocospec(cocospec_block_path,  input_block_name, simulink_block_name, parent_block_name, index, isBdRoot);
%                 end
%             end
        end

        if nb_coco == 0
            warndlg('No cocospec contracts were generated','CoCoSim: Warning');
            return;
        end
        save_system(new_name);
        new_model_path = new_name;
        open(new_name);
        save_system(new_name,[],'OverwriteIfChangedOnDisk',true);
        close_system(translated_nodes,0)
    catch ME
        display_msg(ME.message, MsgType.ERROR, 'generate_invariants_Zustre', '');
        display_msg(ME.getReport(), MsgType.DEBUG, 'generate_invariants_Zustre', '');
        rethrow(ME);
    end
end



